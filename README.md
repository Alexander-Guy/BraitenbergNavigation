# BraitenbergNavigation
Here a simulated basic braitenberg robot is tasked with navigating to a light source using a single photosensor

BTMR - Bacterial tumbling with motor reversal, this is a control system for the braitenberg vehicle which records the outgoing signals to the vehicle motor and then reverses these commands to try and return to its starting position. Bacterial tumbling is basically the motion of spinning until the photosensor reaches the brightest point in a local time series. At which point the robot travels straight towards the light. Because this method has a point of reference for the robot to travel towards it is fairly reliable as if te robot misses it's target it will course correct. However with noise the vehicle takes far longer to get to it's source and with motor reverse it can retrun home to a completly different position to where it started.

BTDR - Bacterial tumbling with dead reckoning, the outward travel for this method is the same as before but the return method uses dead reckoning to return home. Dead reckoning is a method in which all previous steps are integrated together to build an internal model of where the vehicle is relative to it's starting location. This is still vunerable to motor and sensor noise, but because the agent is building an internal model of it's location, it is much more reliable for its return journey.

BTDRG - Angular bacterial tumbling dead reckoning controller (gradient based),instead of the light point being the highest in a spin, the graient of previous light sources is integrated to test the rate of increase/decrease in sensor information. This method is yet more robust than the BTDR as the robot will spin in place more becuase noisy sensor information is ignored for the general trend of the data of the past X timesteps. As the robot spins in place more, motor noise doesn't divert it's final position (relative to start position) from it's internal model as much. As such, the return performance is more reliable aswell. 

BTDRGB - Angular bacterial tumbling dead reckoning with bayesian inference controller (gradient based), finally the agent span multiple times to get a reading of the light source, this mimicked the idea of cephid stars in astronomy, where a light of oscilating luminosity is used to measure distance based on it's peak. From the robot's point of view (because it is spinning) the photosensor is getting an oscillating light source so from this it can find the noiseless value of the light source from its location. Then it can figure out the angular position of this peak source and thus can estimate distance and polar angle from start position. Then it uses bacterial tumbling to get to the light source. Finally, when it believes it has reached the light source, the agent takes a reading of the light to try and figure out how close it is to the light source exactly, this with the dead reckoning position give two gaussian curves that can be integrated to give an estimate of its actual position and return home.
